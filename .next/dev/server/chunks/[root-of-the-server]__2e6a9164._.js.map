{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///Users/christofferwallman/Desktop/Utveckling/NORAV1.2/src/services/ragService.ts"],"sourcesContent":["import { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { OpenAIEmbeddings } from '@langchain/openai';\nimport { RecursiveCharacterTextSplitter } from '@langchain/textsplitters'; // Uppdaterad import\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport interface SearchResult {\n  content: string;\n  metadata: any;\n  similarity: number;\n}\n\nexport class RagService {\n  private supabase: SupabaseClient;\n  private embeddings: OpenAIEmbeddings;\n  private splitter: RecursiveCharacterTextSplitter;\n\n  constructor() {\n    const sbUrl = process.env.SUPABASE_URL;\n    const sbKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // OBS: Använd Service Role Key för att skriva till DB på backend\n\n    if (!sbUrl || !sbKey) {\n      throw new Error(\"Supabase URL or Service Role Key missing in environment variables.\");\n    }\n\n    this.supabase = createClient(sbUrl, sbKey);\n    \n    // Initiera OpenAI Embeddings (text-embedding-3-small)\n    this.embeddings = new OpenAIEmbeddings({\n      modelName: \"text-embedding-3-small\",\n      // API key hämtas automatiskt från process.env.OPENAI_API_KEY\n    });\n\n    // Konfigurera text splitter\n    this.splitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 1000,\n      chunkOverlap: 200,\n      separators: [\"\\n## \", \"\\n# \", \"\\n\\n\", \"\\n\", \" \", \"\"], // Prioritera rubriker vid split\n    });\n  }\n\n  /**\n   * Bearbetar, splittar och lagrar crawlad data.\n   * @param documents Lista med objekt från Firecrawl (måste innehålla markdown och metadata)\n   * @param companyId Unikt ID för företaget/sessionen\n   */\n  async processAndStoreDocuments(documents: any[], companyId: string): Promise<void> {\n    console.log(`Processing ${documents.length} documents for company: ${companyId}`);\n\n    for (const doc of documents) {\n      if (!doc.markdown) continue;\n\n      // 1. Splitta texten i chunks\n      // Vi skickar med metadata så den följer med varje chunk\n      const splitDocs = await this.splitter.createDocuments(\n        [doc.markdown], \n        [{ source: doc.metadata?.sourceURL || 'unknown', ...doc.metadata }]\n      );\n\n      console.log(`Split document into ${splitDocs.length} chunks.`);\n\n      // 2. Skapa embeddings för alla chunks\n      const texts = splitDocs.map((d: { pageContent: string }) => d.pageContent);\n      const vectors = await this.embeddings.embedDocuments(texts);\n\n      // 3. Förbered data för Supabase\n      const rowsToInsert = splitDocs.map((splitDoc: any, index: number) => ({\n        content: splitDoc.pageContent,\n        metadata: splitDoc.metadata,\n        embedding: vectors[index],\n        company_id: companyId\n      }));\n\n      // 4. Spara i Supabase\n      const { error } = await this.supabase\n        .from('knowledge_base') // Updated table name\n        .insert(rowsToInsert);\n\n      if (error) {\n        console.error(\"Error inserting into Supabase:\", error);\n        throw new Error(`Failed to store credentials: ${error.message}`);\n      }\n    }\n    console.log(\"All documents processed and stored successfully.\");\n  }\n\n  /**\n   * Söker efter relevant kontext i Supabase.\n   * Matchar mot SQL-funktionen 'match_documents'.\n   */\n  async performSearch(query: string, companyId: string): Promise<SearchResult[]> {\n    try {\n      // 1. Skapa embedding för användarens fråga\n      const queryEmbedding = await this.embeddings.embedQuery(query);\n\n      // Bestäm tröskelvärde baserat på frågans innehåll\n      const lowerQuery = query.toLowerCase();\n      const isPriceQuery = lowerQuery.includes('pris') || \n                           lowerQuery.includes('kostar') || \n                           lowerQuery.includes('kosta') ||\n                           lowerQuery.includes('price') || \n                           lowerQuery.includes('cost');\n      \n      // Sänk tröskeln rejält för prisfrågor eftersom dessa rader ofta är korta och har låg semantisk likhet\n      // Även generella frågor kan ha lägre matchning, så vi sätter en snällare grundnivå (0.35 istället för 0.5)\n      const threshold = isPriceQuery ? 0.3 : 0.4;\n\n      // 2. Anropa RPC-funktionen i Supabase\n      // Vi ökar match_count till 10 för att fånga upp fler detaljer\n      const { data: result, error } = await this.supabase.rpc('match_documents', {\n        query_embedding: queryEmbedding,\n        match_threshold: threshold,\n        match_count: 10,\n        filter_company_id: companyId\n      });\n\n      if (error) {\n        console.error(\"Error searching Supabase:\", error);\n        throw new Error(`Search failed: ${error.message}`);\n      }\n\n      return result as SearchResult[];\n    } catch (error) {\n      console.error(\"Error in performSearch:\", error);\n      throw error;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///Users/christofferwallman/Desktop/Utveckling/NORAV1.2/src/services/leadService.ts"],"sourcesContent":["import { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\n\nexport class LeadService {\n  private supabase: SupabaseClient;\n\n  constructor() {\n    const supabaseUrl = process.env.SUPABASE_URL;\n    // Vi använder Service Role Key på server-sidan för att ha fulla rättigheter\n    // Fallback till Anon key om service key saknas (men helst service key)\n    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_ANON_KEY;\n\n    if (!supabaseUrl || !supabaseKey) {\n      throw new Error(\"Supabase URL and Key must be defined in environment variables.\");\n    }\n\n    this.supabase = createClient(supabaseUrl, supabaseKey);\n  }\n\n  async saveLead(companyId: string, message: string, email: string = \"\", phone: string = \"\") {\n    console.log(`Saving lead for company ${companyId}. Email: ${email}, Phone: ${phone}`);\n    \n    // Bygger contact_info objekt\n    const contactInfoObj = {\n      raw_email: email,\n      raw_phone: phone,\n      source: 'chat_auto_capture',\n      original_message: message // Backup if message column fails\n    };\n\n    // Använder den nya tabellstrukturen\n    // Notera: 'status' kolumnen fanns inte i det angivna SQL-schemat, så jag tar bort den.\n    const { data, error } = await this.supabase\n      .from('leads')\n      .insert([\n        { \n          company_id: companyId, \n          message: message,\n          email: email || null,\n          phone: phone || null,\n          contact_info: contactInfoObj\n        }\n      ]);\n\n    if (error) {\n      // Fallback: Hantera schema-fel (PGRST204 = Column not found)\n      if (error.code === 'PGRST204') {\n        console.warn(`Schema mismatch detected: ${error.message}. Retrying with minimal fields.`);\n        \n        // Skapa en payload som fungerar med ett begränsat schema (som användarens nuvarande)\n        // Vi lägger all viktig data i contact_info istället\n        const safePayload: any = { \n          company_id: companyId,\n          // Om email är obligatoriskt (NOT NULL) men vi saknar det, måste vi tyvärr skicka något eller låta det fela.\n          // Vi skickar email om det finns.\n          email: email || null,\n          contact_info: contactInfoObj\n        };\n\n        // Försök spara igen\n        const { error: retryError } = await this.supabase\n          .from('leads')\n          .insert([ safePayload ]);\n        \n        if (retryError) {\n             console.error('Error saving lead (retry):', retryError);\n             throw retryError;\n        }\n        return true;\n      }\n\n      console.error('Error saving lead:', error);\n      throw error; // Låt api-routen hantera felet (eller logga det tyst)\n    }\n    \n    return true;\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,iJAAa;AAEN,MAAM;IACH,SAAyB;IAEjC,aAAc;QACZ,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,4EAA4E;QAC5E,uEAAuE;QACvE,MAAM,cAAc,QAAQ,GAAG,CAAC,yBAAyB,IAAI,QAAQ,GAAG,CAAC,iBAAiB;QAE1F,IAAI,CAAC,eAAe,CAAC,aAAa;YAChC,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI,CAAC,QAAQ,GAAG,IAAA,gMAAY,EAAC,aAAa;IAC5C;IAEA,MAAM,SAAS,SAAiB,EAAE,OAAe,EAAE,QAAgB,EAAE,EAAE,QAAgB,EAAE,EAAE;QACzF,QAAQ,GAAG,CAAC,CAAC,wBAAwB,EAAE,UAAU,SAAS,EAAE,MAAM,SAAS,EAAE,OAAO;QAEpF,6BAA6B;QAC7B,MAAM,iBAAiB;YACrB,WAAW;YACX,WAAW;YACX,QAAQ;YACR,kBAAkB,QAAQ,iCAAiC;QAC7D;QAEA,oCAAoC;QACpC,uFAAuF;QACvF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,IAAI,CAAC,QAAQ,CACxC,IAAI,CAAC,SACL,MAAM,CAAC;YACN;gBACE,YAAY;gBACZ,SAAS;gBACT,OAAO,SAAS;gBAChB,OAAO,SAAS;gBAChB,cAAc;YAChB;SACD;QAEH,IAAI,OAAO;YACT,6DAA6D;YAC7D,IAAI,MAAM,IAAI,KAAK,YAAY;gBAC7B,QAAQ,IAAI,CAAC,CAAC,0BAA0B,EAAE,MAAM,OAAO,CAAC,+BAA+B,CAAC;gBAExF,qFAAqF;gBACrF,oDAAoD;gBACpD,MAAM,cAAmB;oBACvB,YAAY;oBACZ,4GAA4G;oBAC5G,iCAAiC;oBACjC,OAAO,SAAS;oBAChB,cAAc;gBAChB;gBAEA,oBAAoB;gBACpB,MAAM,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,IAAI,CAAC,QAAQ,CAC9C,IAAI,CAAC,SACL,MAAM,CAAC;oBAAE;iBAAa;gBAEzB,IAAI,YAAY;oBACX,QAAQ,KAAK,CAAC,8BAA8B;oBAC5C,MAAM;gBACX;gBACA,OAAO;YACT;YAEA,QAAQ,KAAK,CAAC,sBAAsB;YACpC,MAAM,OAAO,sDAAsD;QACrE;QAEA,OAAO;IACT;AACF"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["file:///Users/christofferwallman/Desktop/Utveckling/NORAV1.2/src/prompts/systemPrompts.ts"],"sourcesContent":["export const NORA_SYSTEM_PROMPT = `\nDu är NORA, en intelligent AI-agent som representerar företaget beskrivet i kontexten nedan. Din personlighet är professionell, effektiv och proaktiv.\n\nDitt enda mål är att ge korrekta svar baserat på den tillhandahållna informationen och att hjälpa besökaren vidare i sin kundresa.\n\n### REGLER FÖR SVARSGIVNING:\n1. **Fakta-trohet:** Basera alla svar 100% på \"CONTEXT\". Om informationen saknas, hitta aldrig på något. Säg istället: \"Jag hittar tyvärr ingen specifik information om det på hemsidan just nu, men jag kan hjälpa dig att få kontakt med en medarbetare.\"\n2. **Branschanpassning:** Identifiera företagets bransch utifrån kontexten och anpassa din ton (t.ex. formell för juridik, energisk för e-handel).\n3. **Språksynkronisering:** Svara alltid på samma språk som användaren ställer frågan på. Översätt information från kontexten vid behov.\n\n### HANTERING AV SPECIFIK DATA:\n- **Priser:** Skanna kontexten efter siffror, valutatecken (€, kr, $) eller prislistor. Leta specifikt efter rader som innehåller siffror följt av 'kr', ':-' eller 'SEK'. Om du ser en rad som 'Putsning 150 kr', presentera den alltid även om du i övrigt rekommenderar en offert för större behandlingar. Om priser saknas helt, förklara att kostnaden ofta är behovsprövad och erbjud en offert.\n- **Kontakt:** Om kunden vill boka, ha en offert eller bli kontaktad: Be ALLTID om deras e-post eller telefonnummer först. Säg: \"Vad har du för e-postadress så ber jag en säljare kontakta dig?\" istället för att bara ge ut företagets nummer. Ge endast ut företagets kontaktuppgifter om användaren uttryckligen ber om dem eller vägrar lämna sina egna.\n\n### LEAD GENERATION & CALL TO ACTION (CTA):\n- Ditt primära mål vid köpsignaler (frågor om pris, offert, tjänster) är att samla in användarens kontaktuppgifter (Lead Capture).\n- Varje svar som rör priser, bokning eller specifika tjänster ska avslutas med en uppmaning att lämna kontaktuppgifter.\n- Exempel: \"För att kunna ge dig en exakt offert behöver vi veta lite mer. Lämna din e-post eller ditt telefonnummer här så återkommer vi inom kort!\"\n\n### FORMATEING:\n- Använd punktlistor för tydlighet vid tjänstebeskrivningar.\n- Använd fetstil för viktiga nyckelord (t.ex. priser eller tider).\n\nCONTEXT:\n{context}\n`;\n"],"names":[],"mappings":";;;;AAAO,MAAM,qBAAqB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;AAyBnC,CAAC"}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"sources":["file:///Users/christofferwallman/Desktop/Utveckling/NORAV1.2/src/app/api/chat/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { RagService } from '@/services/ragService';\nimport { LeadService } from '@/services/leadService';\nimport { ChatOpenAI } from '@langchain/openai';\nimport { HumanMessage, SystemMessage, AIMessage, BaseMessage } from '@langchain/core/messages';\nimport { NORA_SYSTEM_PROMPT } from '@/prompts/systemPrompts';\n\nconst chatModel = new ChatOpenAI({\n  modelName: \"gpt-4o\",\n  temperature: 0.7,\n  streaming: true,\n});\n\n// En lättviktig modell för att formulera om sökfrågor\nconst rephraseModel = new ChatOpenAI({\n  modelName: \"gpt-3.5-turbo\",\n  temperature: 0,\n});\n\nexport async function POST(req: Request) {\n  try {\n    // Instansiera services här istället för globalt\n    const ragService = new RagService();\n    const leadService = new LeadService();\n\n    const body = await req.json();\n    const { messages, companyId, message: legacyMessage } = body;\n\n    // Hämta sista meddelandet (stödjer både ny array-struktur och gammal string-struktur)\n    const lastMessage = Array.isArray(messages) \n      ? messages[messages.length - 1].content \n      : legacyMessage;\n\n    if (!lastMessage || !companyId) {\n      return NextResponse.json(\n        { error: \"Message and companyId are required\" },\n        { status: 400 }\n      );\n    }\n\n    // 0. Lead Capture Check (Email & Phone)\n    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g;\n    const phoneRegex = /(?:(?:\\+46)|0)\\s?\\d{1,3}[\\s-]?\\d{2,4}[\\s-]?\\d{2,4}/g;\n    \n    const foundEmails = lastMessage.match(emailRegex);\n    const foundPhones = lastMessage.match(phoneRegex);\n    \n    let contactInfo = \"\";\n    let email = \"\";\n    let phone = \"\";\n\n    if (foundEmails && foundEmails.length > 0) {\n      email = foundEmails[0];\n      contactInfo = email;\n    } else if (foundPhones && foundPhones.length > 0) {\n      phone = foundPhones[0];\n      contactInfo = phone;\n    }\n\n    if (contactInfo) {\n      console.log(`Detected potential lead: ${contactInfo}`);\n      \n      // Vi kör detta \"fire and forget\" men fångar fel för att inte krascha chatten\n      // Nu anropar vi med (companyId, message, email, phone)\n      leadService.saveLead(companyId, lastMessage, email, phone).catch(err => {\n        console.error(\"Failed to save lead automatically:\", err);\n      });\n    }\n\n    // 1. Förbered sökfråga (Contextual Retrieval)\n    // Om vi har historik, be AI formulera om frågan så den blir 'self-contained' för bättre sökresultat\n    let queryToSearch = lastMessage;\n    const historyMessages = Array.isArray(messages) ? messages.slice(0, -1) : [];\n\n    if (historyMessages.length > 0) {\n      try {\n        const rephrasePrompt = `\nGivet följande konversation och en uppföljande fråga, formulera om uppföljningsfrågan så att den blir en fristående fråga som fångar hela kontexten. Behåll originalspråket (svenska).\n\nKonversation:\n${historyMessages.map((m: any) => `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`).join('\\n')}\n\nUppföljande fråga: ${lastMessage}\n\nFristående fråga:`;\n\n        const rephrasedResponse = await rephraseModel.invoke([new HumanMessage(rephrasePrompt)]);\n        \n        if (rephrasedResponse.content) {\n          queryToSearch = rephrasedResponse.content as string;\n          console.log(`Rephrasing query: \"${lastMessage}\" -> \"${queryToSearch}\"`);\n        }\n      } catch (e) {\n        console.error(\"Failed to rephrase query, using original:\", e);\n      }\n    }\n\n    // 2. Sök relevant kontext (RAG) med den (eventuellt) förbättrade frågan\n    const searchResults = await ragService.performSearch(queryToSearch, companyId);\n    \n    const contextText = searchResults.map(r => r.content).join(\"\\n\\n---\\n\\n\");\n    const sources = searchResults.map(r => r.metadata?.sourceURL).filter(Boolean);\n\n    console.log(`Found ${searchResults.length} context chunks for query: \"${queryToSearch}\"`);\n\n    // 3. Bygg prompten\n    const systemPromptEncoded = NORA_SYSTEM_PROMPT.replace(\"{context}\", contextText || \"Ingen specifik information hittades.\");\n\n    // Bygg upp meddelar-historiken för LangChain\n    // Vi använder BaseMessage[] för att tillåta olika typer av meddelanden\n    const langchainMessages: BaseMessage[] = [new SystemMessage(systemPromptEncoded)];\n\n    if (Array.isArray(messages)) {\n      // Lägg till historiken. Vi exkluderar sista meddelandet här för att lägga det sist explicit\n      // eller loopar igenom alla.\n      messages.forEach((msg: { role: string, content: string }) => {\n        if (msg.role === 'user') {\n          langchainMessages.push(new HumanMessage(msg.content));\n        } else if (msg.role === 'assistant') {\n          langchainMessages.push(new AIMessage(msg.content));\n        }\n      });\n    } else {\n      // Fallback om bara ett meddelande skickades\n      langchainMessages.push(new HumanMessage(lastMessage));\n    }\n\n    // 3. Skapa en stream för svaret\n    const stream = new ReadableStream({\n      async start(controller) {\n        const streamResponse = await chatModel.stream(langchainMessages);\n        \n        for await (const chunk of streamResponse) {\n          if (chunk.content) {\n            controller.enqueue(new TextEncoder().encode(chunk.content as string));\n          }\n        }\n        controller.close();\n      },\n    });\n\n    // 4. Returnera streamen\n    // Vi skickar sources i en custom header så klienten kan läsa dem\n    return new Response(stream, {\n      headers: {\n        'Content-Type': 'text/plain; charset=utf-8',\n        'X-Sources': JSON.stringify(sources),\n      },\n    });\n\n  } catch (error: any) {\n    console.error(\"Chat error:\", error);\n    return NextResponse.json(\n      { error: error.message || \"Internal Server Error\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}