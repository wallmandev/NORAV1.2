module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[project]/src/services/ragService.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RagService",
    ()=>RagService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/embeddings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/textsplitters/dist/index.js [app-route] (ecmascript) <locals>"); // Uppdaterad import
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$text_splitter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/textsplitters/dist/text_splitter.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].config();
class RagService {
    supabase;
    embeddings;
    splitter;
    constructor(){
        const sbUrl = process.env.SUPABASE_URL;
        const sbKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // OBS: Använd Service Role Key för att skriva till DB på backend
        if (!sbUrl || !sbKey) {
            throw new Error("Supabase URL or Service Role Key missing in environment variables.");
        }
        this.supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(sbUrl, sbKey);
        // Initiera OpenAI Embeddings (text-embedding-3-small)
        this.embeddings = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAIEmbeddings"]({
            modelName: "text-embedding-3-small"
        });
        // Konfigurera text splitter
        this.splitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$text_splitter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RecursiveCharacterTextSplitter"]({
            chunkSize: 1000,
            chunkOverlap: 200,
            separators: [
                "\n## ",
                "\n# ",
                "\n\n",
                "\n",
                " ",
                ""
            ]
        });
    }
    /**
   * Bearbetar, splittar och lagrar crawlad data.
   * @param documents Lista med objekt från Firecrawl (måste innehålla markdown och metadata)
   * @param companyId Unikt ID för företaget/sessionen
   */ async processAndStoreDocuments(documents, companyId) {
        console.log(`Processing ${documents.length} documents for company: ${companyId}`);
        for (const doc of documents){
            if (!doc.markdown) continue;
            // 1. Splitta texten i chunks
            // Vi skickar med metadata så den följer med varje chunk
            const splitDocs = await this.splitter.createDocuments([
                doc.markdown
            ], [
                {
                    source: doc.metadata?.sourceURL || 'unknown',
                    ...doc.metadata
                }
            ]);
            console.log(`Split document into ${splitDocs.length} chunks.`);
            // 2. Skapa embeddings för alla chunks
            const texts = splitDocs.map((d)=>d.pageContent);
            const vectors = await this.embeddings.embedDocuments(texts);
            // 3. Förbered data för Supabase
            const rowsToInsert = splitDocs.map((splitDoc, index)=>({
                    content: splitDoc.pageContent,
                    metadata: splitDoc.metadata,
                    embedding: vectors[index],
                    company_id: companyId
                }));
            // 4. Spara i Supabase
            const { error } = await this.supabase.from('knowledge_base') // Updated table name
            .insert(rowsToInsert);
            if (error) {
                console.error("Error inserting into Supabase:", error);
                throw new Error(`Failed to store credentials: ${error.message}`);
            }
        }
        console.log("All documents processed and stored successfully.");
    }
    /**
   * Söker efter relevant kontext i Supabase.
   * Matchar mot SQL-funktionen 'match_documents'.
   */ async performSearch(query, companyId) {
        try {
            // 1. Skapa embedding för användarens fråga
            const queryEmbedding = await this.embeddings.embedQuery(query);
            // Bestäm tröskelvärde baserat på frågans innehåll
            const lowerQuery = query.toLowerCase();
            const isPriceQuery = lowerQuery.includes('pris') || lowerQuery.includes('kostar') || lowerQuery.includes('kosta') || lowerQuery.includes('price') || lowerQuery.includes('cost');
            // Sänk tröskeln rejält för prisfrågor eftersom dessa rader ofta är korta och har låg semantisk likhet
            // Även generella frågor kan ha lägre matchning, så vi sätter en snällare grundnivå (0.35 istället för 0.5)
            const threshold = isPriceQuery ? 0.3 : 0.4;
            // 2. Anropa RPC-funktionen i Supabase
            // Vi ökar match_count till 10 för att fånga upp fler detaljer
            const { data: result, error } = await this.supabase.rpc('match_documents', {
                query_embedding: queryEmbedding,
                match_threshold: threshold,
                match_count: 10,
                filter_company_id: companyId
            });
            if (error) {
                console.error("Error searching Supabase:", error);
                throw new Error(`Search failed: ${error.message}`);
            }
            return result;
        } catch (error) {
            console.error("Error in performSearch:", error);
            throw error;
        }
    }
}
}),
"[project]/src/services/leadService.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LeadService",
    ()=>LeadService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["config"]();
class LeadService {
    supabase;
    constructor(){
        const supabaseUrl = process.env.SUPABASE_URL;
        // Vi använder Service Role Key på server-sidan för att ha fulla rättigheter
        // Fallback till Anon key om service key saknas (men helst service key)
        const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_ANON_KEY;
        if (!supabaseUrl || !supabaseKey) {
            throw new Error("Supabase URL and Key must be defined in environment variables.");
        }
        this.supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseKey);
    }
    async saveLead(companyId, message, email = "", phone = "") {
        console.log(`Saving lead for company ${companyId}. Email: ${email}, Phone: ${phone}`);
        // Bygger contact_info objekt
        const contactInfoObj = {
            raw_email: email,
            raw_phone: phone,
            source: 'chat_auto_capture',
            original_message: message // Backup if message column fails
        };
        // Använder den nya tabellstrukturen
        // Notera: 'status' kolumnen fanns inte i det angivna SQL-schemat, så jag tar bort den.
        const { data, error } = await this.supabase.from('leads').insert([
            {
                company_id: companyId,
                message: message,
                email: email || null,
                phone: phone || null,
                contact_info: contactInfoObj
            }
        ]);
        if (error) {
            // Fallback: Hantera schema-fel (PGRST204 = Column not found)
            if (error.code === 'PGRST204') {
                console.warn(`Schema mismatch detected: ${error.message}. Retrying with minimal fields.`);
                // Skapa en payload som fungerar med ett begränsat schema (som användarens nuvarande)
                // Vi lägger all viktig data i contact_info istället
                const safePayload = {
                    company_id: companyId,
                    // Om email är obligatoriskt (NOT NULL) men vi saknar det, måste vi tyvärr skicka något eller låta det fela.
                    // Vi skickar email om det finns.
                    email: email || null,
                    contact_info: contactInfoObj
                };
                // Försök spara igen
                const { error: retryError } = await this.supabase.from('leads').insert([
                    safePayload
                ]);
                if (retryError) {
                    console.error('Error saving lead (retry):', retryError);
                    throw retryError;
                }
                return true;
            }
            console.error('Error saving lead:', error);
            throw error; // Låt api-routen hantera felet (eller logga det tyst)
        }
        return true;
    }
}
}),
"[project]/src/prompts/systemPrompts.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NORA_SYSTEM_PROMPT",
    ()=>NORA_SYSTEM_PROMPT
]);
const NORA_SYSTEM_PROMPT = `
Du är NORA, en intelligent AI-agent som representerar företaget beskrivet i kontexten nedan. Din personlighet är professionell, effektiv och proaktiv.

Ditt enda mål är att ge korrekta svar baserat på den tillhandahållna informationen och att hjälpa besökaren vidare i sin kundresa.

### REGLER FÖR SVARSGIVNING:
1. **Fakta-trohet:** Basera alla svar 100% på "CONTEXT". Om informationen saknas, hitta aldrig på något. Säg istället: "Jag hittar tyvärr ingen specifik information om det på hemsidan just nu, men jag kan hjälpa dig att få kontakt med en medarbetare."
2. **Branschanpassning:** Identifiera företagets bransch utifrån kontexten och anpassa din ton (t.ex. formell för juridik, energisk för e-handel).
3. **Språksynkronisering:** Svara alltid på samma språk som användaren ställer frågan på. Översätt information från kontexten vid behov.

### HANTERING AV SPECIFIK DATA:
- **Priser:** Skanna kontexten efter siffror, valutatecken (€, kr, $) eller prislistor. Leta specifikt efter rader som innehåller siffror följt av 'kr', ':-' eller 'SEK'. Om du ser en rad som 'Putsning 150 kr', presentera den alltid även om du i övrigt rekommenderar en offert för större behandlingar. Om priser saknas helt, förklara att kostnaden ofta är behovsprövad och erbjud en offert.
- **Kontakt:** Om kunden vill boka, ha en offert eller bli kontaktad: Be ALLTID om deras e-post eller telefonnummer först. Säg: "Vad har du för e-postadress så ber jag en säljare kontakta dig?" istället för att bara ge ut företagets nummer. Ge endast ut företagets kontaktuppgifter om användaren uttryckligen ber om dem eller vägrar lämna sina egna.

### LEAD GENERATION & CALL TO ACTION (CTA):
- Ditt primära mål vid köpsignaler (frågor om pris, offert, tjänster) är att samla in användarens kontaktuppgifter (Lead Capture).
- Varje svar som rör priser, bokning eller specifika tjänster ska avslutas med en uppmaning att lämna kontaktuppgifter.
- Exempel: "För att kunna ge dig en exakt offert behöver vi veta lite mer. Lämna din e-post eller ditt telefonnummer här så återkommer vi inom kort!"

### FORMATEING:
- Använd punktlistor för tydlighet vid tjänstebeskrivningar.
- Använd fetstil för viktiga nyckelord (t.ex. priser eller tider).

CONTEXT:
{context}
`;
}),
"[project]/src/app/api/chat/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$ragService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/ragService.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$leadService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/leadService.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$chat_models$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/chat_models/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/core/dist/messages/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$human$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/core/dist/messages/human.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$system$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/core/dist/messages/system.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$ai$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/core/dist/messages/ai.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$prompts$2f$systemPrompts$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/prompts/systemPrompts.ts [app-route] (ecmascript)");
;
;
;
;
;
;
const chatModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$chat_models$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChatOpenAI"]({
    modelName: "gpt-4o",
    temperature: 0.7,
    streaming: true
});
// En lättviktig modell för att formulera om sökfrågor
const rephraseModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$chat_models$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChatOpenAI"]({
    modelName: "gpt-3.5-turbo",
    temperature: 0
});
async function POST(req) {
    try {
        // Instansiera services här istället för globalt
        const ragService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$ragService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RagService"]();
        const leadService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$leadService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LeadService"]();
        const body = await req.json();
        const { messages, companyId, message: legacyMessage } = body;
        // Hämta sista meddelandet (stödjer både ny array-struktur och gammal string-struktur)
        const lastMessage = Array.isArray(messages) ? messages[messages.length - 1].content : legacyMessage;
        if (!lastMessage || !companyId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Message and companyId are required"
            }, {
                status: 400
            });
        }
        // 0. Lead Capture Check (Email & Phone)
        const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
        const phoneRegex = /(?:(?:\+46)|0)\s?\d{1,3}[\s-]?\d{2,4}[\s-]?\d{2,4}/g;
        const foundEmails = lastMessage.match(emailRegex);
        const foundPhones = lastMessage.match(phoneRegex);
        let contactInfo = "";
        let email = "";
        let phone = "";
        if (foundEmails && foundEmails.length > 0) {
            email = foundEmails[0];
            contactInfo = email;
        } else if (foundPhones && foundPhones.length > 0) {
            phone = foundPhones[0];
            contactInfo = phone;
        }
        if (contactInfo) {
            console.log(`Detected potential lead: ${contactInfo}`);
            // Vi kör detta "fire and forget" men fångar fel för att inte krascha chatten
            // Nu anropar vi med (companyId, message, email, phone)
            leadService.saveLead(companyId, lastMessage, email, phone).catch((err)=>{
                console.error("Failed to save lead automatically:", err);
            });
        }
        // 1. Förbered sökfråga (Contextual Retrieval)
        // Om vi har historik, be AI formulera om frågan så den blir 'self-contained' för bättre sökresultat
        let queryToSearch = lastMessage;
        const historyMessages = Array.isArray(messages) ? messages.slice(0, -1) : [];
        if (historyMessages.length > 0) {
            try {
                const rephrasePrompt = `
Givet följande konversation och en uppföljande fråga, formulera om uppföljningsfrågan så att den blir en fristående fråga som fångar hela kontexten. Behåll originalspråket (svenska).

Konversation:
${historyMessages.map((m)=>`${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`).join('\n')}

Uppföljande fråga: ${lastMessage}

Fristående fråga:`;
                const rephrasedResponse = await rephraseModel.invoke([
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$human$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HumanMessage"](rephrasePrompt)
                ]);
                if (rephrasedResponse.content) {
                    queryToSearch = rephrasedResponse.content;
                    console.log(`Rephrasing query: "${lastMessage}" -> "${queryToSearch}"`);
                }
            } catch (e) {
                console.error("Failed to rephrase query, using original:", e);
            }
        }
        // 2. Sök relevant kontext (RAG) med den (eventuellt) förbättrade frågan
        const searchResults = await ragService.performSearch(queryToSearch, companyId);
        const contextText = searchResults.map((r)=>r.content).join("\n\n---\n\n");
        const sources = searchResults.map((r)=>r.metadata?.sourceURL).filter(Boolean);
        console.log(`Found ${searchResults.length} context chunks for query: "${queryToSearch}"`);
        // 3. Bygg prompten
        const systemPromptEncoded = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$prompts$2f$systemPrompts$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NORA_SYSTEM_PROMPT"].replace("{context}", contextText || "Ingen specifik information hittades.");
        // Bygg upp meddelar-historiken för LangChain
        // Vi använder BaseMessage[] för att tillåta olika typer av meddelanden
        const langchainMessages = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$system$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SystemMessage"](systemPromptEncoded)
        ];
        if (Array.isArray(messages)) {
            // Lägg till historiken. Vi exkluderar sista meddelandet här för att lägga det sist explicit
            // eller loopar igenom alla.
            messages.forEach((msg)=>{
                if (msg.role === 'user') {
                    langchainMessages.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$human$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HumanMessage"](msg.content));
                } else if (msg.role === 'assistant') {
                    langchainMessages.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$ai$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AIMessage"](msg.content));
                }
            });
        } else {
            // Fallback om bara ett meddelande skickades
            langchainMessages.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$human$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HumanMessage"](lastMessage));
        }
        // 3. Skapa en stream för svaret
        const stream = new ReadableStream({
            async start (controller) {
                const streamResponse = await chatModel.stream(langchainMessages);
                for await (const chunk of streamResponse){
                    if (chunk.content) {
                        controller.enqueue(new TextEncoder().encode(chunk.content));
                    }
                }
                controller.close();
            }
        });
        // 4. Returnera streamen
        // Vi skickar sources i en custom header så klienten kan läsa dem
        return new Response(stream, {
            headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                'X-Sources': JSON.stringify(sources)
            }
        });
    } catch (error) {
        console.error("Chat error:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: error.message || "Internal Server Error"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__2e6a9164._.js.map