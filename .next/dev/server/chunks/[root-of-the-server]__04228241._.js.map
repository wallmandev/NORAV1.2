{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///Users/christofferwallman/Desktop/Utveckling/NORAV1.2/src/services/ragService.ts"],"sourcesContent":["import { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { OpenAIEmbeddings } from '@langchain/openai';\nimport { RecursiveCharacterTextSplitter } from '@langchain/textsplitters'; // Uppdaterad import\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport interface SearchResult {\n  content: string;\n  metadata: any;\n  similarity: number;\n}\n\nexport class RagService {\n  private supabase: SupabaseClient;\n  private embeddings: OpenAIEmbeddings;\n  private splitter: RecursiveCharacterTextSplitter;\n\n  constructor() {\n    const sbUrl = process.env.SUPABASE_URL;\n    const sbKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // OBS: Använd Service Role Key för att skriva till DB på backend\n\n    if (!sbUrl || !sbKey) {\n      throw new Error(\"Supabase URL or Service Role Key missing in environment variables.\");\n    }\n\n    this.supabase = createClient(sbUrl, sbKey);\n    \n    // Initiera OpenAI Embeddings (text-embedding-3-small)\n    this.embeddings = new OpenAIEmbeddings({\n      modelName: \"text-embedding-3-small\",\n      // API key hämtas automatiskt från process.env.OPENAI_API_KEY\n    });\n\n    // Konfigurera text splitter\n    this.splitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 1000,\n      chunkOverlap: 200,\n      separators: [\"\\n## \", \"\\n# \", \"\\n\\n\", \"\\n\", \" \", \"\"], // Prioritera rubriker vid split\n    });\n  }\n\n  /**\n   * Bearbetar, splittar och lagrar crawlad data.\n   * @param documents Lista med objekt från Firecrawl (måste innehålla markdown och metadata)\n   * @param companyId Unikt ID för företaget/sessionen\n   */\n  async processAndStoreDocuments(documents: any[], companyId: string): Promise<void> {\n    console.log(`Processing ${documents.length} documents for company: ${companyId}`);\n\n    for (const doc of documents) {\n      if (!doc.markdown) continue;\n\n      // 1. Splitta texten i chunks\n      // Vi skickar med metadata så den följer med varje chunk\n      const splitDocs = await this.splitter.createDocuments(\n        [doc.markdown], \n        [{ source: doc.metadata?.sourceURL || 'unknown', ...doc.metadata }]\n      );\n\n      console.log(`Split document into ${splitDocs.length} chunks.`);\n\n      // 2. Skapa embeddings för alla chunks\n      const texts = splitDocs.map((d: { pageContent: string }) => d.pageContent);\n      const vectors = await this.embeddings.embedDocuments(texts);\n\n      // 3. Förbered data för Supabase\n      const rowsToInsert = splitDocs.map((splitDoc: any, index: number) => ({\n        content: splitDoc.pageContent,\n        metadata: splitDoc.metadata,\n        embedding: vectors[index],\n        company_id: companyId\n      }));\n\n      // 4. Spara i Supabase\n      const { error } = await this.supabase\n        .from('documents')\n        .insert(rowsToInsert);\n\n      if (error) {\n        console.error(\"Error inserting into Supabase:\", error);\n        throw new Error(`Failed to store credentials: ${error.message}`);\n      }\n    }\n    console.log(\"All documents processed and stored successfully.\");\n  }\n\n  /**\n   * Söker efter relevant kontext i Supabase.\n   * Matchar mot SQL-funktionen 'match_documents'.\n   */\n  async performSearch(query: string, companyId: string): Promise<SearchResult[]> {\n    try {\n      // 1. Skapa embedding för användarens fråga\n      const queryEmbedding = await this.embeddings.embedQuery(query);\n\n      // 2. Anropa RPC-funktionen i Supabase\n      // Vi sätter match_count till 5 för att få tillräckligt med kontext\n      const { data: result, error } = await this.supabase.rpc('match_documents', {\n        query_embedding: queryEmbedding,\n        match_threshold: 0.5, // Vi filtrerar bort irrelevant brus (< 50% match)\n        match_count: 5,\n        filter_company_id: companyId\n      });\n\n      if (error) {\n        console.error(\"Error searching Supabase:\", error);\n        throw new Error(`Search failed: ${error.message}`);\n      }\n\n      return result as SearchResult[];\n    } catch (error) {\n      console.error(\"Error in performSearch:\", error);\n      throw error;\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA,kTAA2E,oBAAoB;AAA/F;AACA;;;;;AAEA,kJAAM,CAAC,MAAM;AAQN,MAAM;IACH,SAAyB;IACzB,WAA6B;IAC7B,SAAyC;IAEjD,aAAc;QACZ,MAAM,QAAQ,QAAQ,GAAG,CAAC,YAAY;QACtC,MAAM,QAAQ,QAAQ,GAAG,CAAC,yBAAyB,EAAE,iEAAiE;QAEtH,IAAI,CAAC,SAAS,CAAC,OAAO;YACpB,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI,CAAC,QAAQ,GAAG,IAAA,gMAAY,EAAC,OAAO;QAEpC,sDAAsD;QACtD,IAAI,CAAC,UAAU,GAAG,IAAI,iLAAgB,CAAC;YACrC,WAAW;QAEb;QAEA,4BAA4B;QAC5B,IAAI,CAAC,QAAQ,GAAG,IAAI,yMAA8B,CAAC;YACjD,WAAW;YACX,cAAc;YACd,YAAY;gBAAC;gBAAS;gBAAQ;gBAAQ;gBAAM;gBAAK;aAAG;QACtD;IACF;IAEA;;;;GAIC,GACD,MAAM,yBAAyB,SAAgB,EAAE,SAAiB,EAAiB;QACjF,QAAQ,GAAG,CAAC,CAAC,WAAW,EAAE,UAAU,MAAM,CAAC,wBAAwB,EAAE,WAAW;QAEhF,KAAK,MAAM,OAAO,UAAW;YAC3B,IAAI,CAAC,IAAI,QAAQ,EAAE;YAEnB,6BAA6B;YAC7B,wDAAwD;YACxD,MAAM,YAAY,MAAM,IAAI,CAAC,QAAQ,CAAC,eAAe,CACnD;gBAAC,IAAI,QAAQ;aAAC,EACd;gBAAC;oBAAE,QAAQ,IAAI,QAAQ,EAAE,aAAa;oBAAW,GAAG,IAAI,QAAQ;gBAAC;aAAE;YAGrE,QAAQ,GAAG,CAAC,CAAC,oBAAoB,EAAE,UAAU,MAAM,CAAC,QAAQ,CAAC;YAE7D,sCAAsC;YACtC,MAAM,QAAQ,UAAU,GAAG,CAAC,CAAC,IAA+B,EAAE,WAAW;YACzE,MAAM,UAAU,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC;YAErD,gCAAgC;YAChC,MAAM,eAAe,UAAU,GAAG,CAAC,CAAC,UAAe,QAAkB,CAAC;oBACpE,SAAS,SAAS,WAAW;oBAC7B,UAAU,SAAS,QAAQ;oBAC3B,WAAW,OAAO,CAAC,MAAM;oBACzB,YAAY;gBACd,CAAC;YAED,sBAAsB;YACtB,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,IAAI,CAAC,QAAQ,CAClC,IAAI,CAAC,aACL,MAAM,CAAC;YAEV,IAAI,OAAO;gBACT,QAAQ,KAAK,CAAC,kCAAkC;gBAChD,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,MAAM,OAAO,EAAE;YACjE;QACF;QACA,QAAQ,GAAG,CAAC;IACd;IAEA;;;GAGC,GACD,MAAM,cAAc,KAAa,EAAE,SAAiB,EAA2B;QAC7E,IAAI;YACF,2CAA2C;YAC3C,MAAM,iBAAiB,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC;YAExD,sCAAsC;YACtC,mEAAmE;YACnE,MAAM,EAAE,MAAM,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,mBAAmB;gBACzE,iBAAiB;gBACjB,iBAAiB;gBACjB,aAAa;gBACb,mBAAmB;YACrB;YAEA,IAAI,OAAO;gBACT,QAAQ,KAAK,CAAC,6BAA6B;gBAC3C,MAAM,IAAI,MAAM,CAAC,eAAe,EAAE,MAAM,OAAO,EAAE;YACnD;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;YACzC,MAAM;QACR;IACF;AACF"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///Users/christofferwallman/Desktop/Utveckling/NORAV1.2/src/prompts/systemPrompts.ts"],"sourcesContent":["export const NORA_SYSTEM_PROMPT = `\nDu är NORA, en professionell, hjälpsam och säljorienterad AI-assistent som representerar företaget beskrivet i kontexten nedan.\n\nDitt mål är att besvara besökarens frågor korrekt baserat *enbart* på den tillhandahållna informationen (Context).\n\nREGLER FÖR DINA SVAR:\n1. Svara alltid med en vänlig och professionell ton, som en kunnig medarbetare på företaget.\n2. Basera ditt svar 100% på \"CONTEXT\" nedan. Hitta inte på fakta.\n3. Om svaret inte finns i kontexten, svara INTE \"Jag vet inte\". Säg istället något i stil med:\n   \"Jag har inte exakta detaljer om det just nu, men jag kan koppla dig till vårt säljteam för mer information,\" eller \"Den specifika informationen finns inte i min nuvarande utbildning, men berätta gärna mer om vad ni letar efter så kan jag se vad jag hittar.\"\n4. Håll svaren koncisa men informativa. Använd markdown för listor om det passar.\n5. Om användaren frågar vem du är, svara att du är NORA, en AI-agent som hjälper besökare att hitta rätt information.\n\nCONTEXT:\n{context}\n`;\n"],"names":[],"mappings":";;;;AAAO,MAAM,qBAAqB,CAAC;;;;;;;;;;;;;;;AAenC,CAAC"}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///Users/christofferwallman/Desktop/Utveckling/NORAV1.2/src/app/api/chat/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { RagService } from '@/services/ragService';\nimport { ChatOpenAI } from '@langchain/openai';\nimport { HumanMessage, SystemMessage } from '@langchain/core/messages';\nimport { NORA_SYSTEM_PROMPT } from '@/prompts/systemPrompts';\n\nconst ragService = new RagService();\nconst chatModel = new ChatOpenAI({\n  modelName: \"gpt-4o\",\n  temperature: 0.7,\n  streaming: true,\n});\n\nexport async function POST(req: Request) {\n  try {\n    const body = await req.json();\n    const { message, companyId } = body;\n\n    if (!message || !companyId) {\n      return NextResponse.json(\n        { error: \"Message and companyId are required\" },\n        { status: 400 }\n      );\n    }\n\n    // 1. Sök relevant kontext (RAG)\n    const searchResults = await ragService.performSearch(message, companyId);\n    \n    const contextText = searchResults.map(r => r.content).join(\"\\n\\n---\\n\\n\");\n    const sources = searchResults.map(r => r.metadata?.sourceURL).filter(Boolean);\n\n    console.log(`Found ${searchResults.length} context chunks for query: \"${message}\"`);\n\n    // 2. Bygg prompten\n    const systemPromptEncoded = NORA_SYSTEM_PROMPT.replace(\"{context}\", contextText || \"Ingen specifik information hittades.\");\n\n    const messages = [\n      new SystemMessage(systemPromptEncoded),\n      new HumanMessage(message)\n    ];\n\n    // 3. Skapa en stream för svaret\n    const stream = new ReadableStream({\n      async start(controller) {\n        const streamResponse = await chatModel.stream(messages);\n        \n        for await (const chunk of streamResponse) {\n          if (chunk.content) {\n            controller.enqueue(new TextEncoder().encode(chunk.content as string));\n          }\n        }\n        controller.close();\n      },\n    });\n\n    // 4. Returnera streamen\n    // Vi skickar sources i en custom header så klienten kan läsa dem\n    return new Response(stream, {\n      headers: {\n        'Content-Type': 'text/plain; charset=utf-8',\n        'X-Sources': JSON.stringify(sources),\n      },\n    });\n\n  } catch (error: any) {\n    console.error(\"Chat error:\", error);\n    return NextResponse.json(\n      { error: error.message || \"Internal Server Error\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;AAEA,MAAM,aAAa,IAAI,6IAAU;AACjC,MAAM,YAAY,IAAI,qLAAU,CAAC;IAC/B,WAAW;IACX,aAAa;IACb,WAAW;AACb;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG;QAE/B,IAAI,CAAC,WAAW,CAAC,WAAW;YAC1B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAqC,GAC9C;gBAAE,QAAQ;YAAI;QAElB;QAEA,gCAAgC;QAChC,MAAM,gBAAgB,MAAM,WAAW,aAAa,CAAC,SAAS;QAE9D,MAAM,cAAc,cAAc,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,EAAE,IAAI,CAAC;QAC3D,MAAM,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,EAAE,QAAQ,EAAE,WAAW,MAAM,CAAC;QAErE,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,cAAc,MAAM,CAAC,4BAA4B,EAAE,QAAQ,CAAC,CAAC;QAElF,mBAAmB;QACnB,MAAM,sBAAsB,uJAAkB,CAAC,OAAO,CAAC,aAAa,eAAe;QAEnF,MAAM,WAAW;YACf,IAAI,oLAAa,CAAC;YAClB,IAAI,kLAAY,CAAC;SAClB;QAED,gCAAgC;QAChC,MAAM,SAAS,IAAI,eAAe;YAChC,MAAM,OAAM,UAAU;gBACpB,MAAM,iBAAiB,MAAM,UAAU,MAAM,CAAC;gBAE9C,WAAW,MAAM,SAAS,eAAgB;oBACxC,IAAI,MAAM,OAAO,EAAE;wBACjB,WAAW,OAAO,CAAC,IAAI,cAAc,MAAM,CAAC,MAAM,OAAO;oBAC3D;gBACF;gBACA,WAAW,KAAK;YAClB;QACF;QAEA,wBAAwB;QACxB,iEAAiE;QACjE,OAAO,IAAI,SAAS,QAAQ;YAC1B,SAAS;gBACP,gBAAgB;gBAChB,aAAa,KAAK,SAAS,CAAC;YAC9B;QACF;IAEF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,eAAe;QAC7B,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,MAAM,OAAO,IAAI;QAAwB,GAClD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}