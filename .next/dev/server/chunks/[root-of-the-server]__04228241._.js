module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[project]/src/services/ragService.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RagService",
    ()=>RagService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/embeddings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/textsplitters/dist/index.js [app-route] (ecmascript) <locals>"); // Uppdaterad import
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$text_splitter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/textsplitters/dist/text_splitter.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].config();
class RagService {
    supabase;
    embeddings;
    splitter;
    constructor(){
        const sbUrl = process.env.SUPABASE_URL;
        const sbKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // OBS: Använd Service Role Key för att skriva till DB på backend
        if (!sbUrl || !sbKey) {
            throw new Error("Supabase URL or Service Role Key missing in environment variables.");
        }
        this.supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(sbUrl, sbKey);
        // Initiera OpenAI Embeddings (text-embedding-3-small)
        this.embeddings = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAIEmbeddings"]({
            modelName: "text-embedding-3-small"
        });
        // Konfigurera text splitter
        this.splitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$text_splitter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RecursiveCharacterTextSplitter"]({
            chunkSize: 1000,
            chunkOverlap: 200,
            separators: [
                "\n## ",
                "\n# ",
                "\n\n",
                "\n",
                " ",
                ""
            ]
        });
    }
    /**
   * Bearbetar, splittar och lagrar crawlad data.
   * @param documents Lista med objekt från Firecrawl (måste innehålla markdown och metadata)
   * @param companyId Unikt ID för företaget/sessionen
   */ async processAndStoreDocuments(documents, companyId) {
        console.log(`Processing ${documents.length} documents for company: ${companyId}`);
        for (const doc of documents){
            if (!doc.markdown) continue;
            // 1. Splitta texten i chunks
            // Vi skickar med metadata så den följer med varje chunk
            const splitDocs = await this.splitter.createDocuments([
                doc.markdown
            ], [
                {
                    source: doc.metadata?.sourceURL || 'unknown',
                    ...doc.metadata
                }
            ]);
            console.log(`Split document into ${splitDocs.length} chunks.`);
            // 2. Skapa embeddings för alla chunks
            const texts = splitDocs.map((d)=>d.pageContent);
            const vectors = await this.embeddings.embedDocuments(texts);
            // 3. Förbered data för Supabase
            const rowsToInsert = splitDocs.map((splitDoc, index)=>({
                    content: splitDoc.pageContent,
                    metadata: splitDoc.metadata,
                    embedding: vectors[index],
                    company_id: companyId
                }));
            // 4. Spara i Supabase
            const { error } = await this.supabase.from('documents').insert(rowsToInsert);
            if (error) {
                console.error("Error inserting into Supabase:", error);
                throw new Error(`Failed to store credentials: ${error.message}`);
            }
        }
        console.log("All documents processed and stored successfully.");
    }
    /**
   * Söker efter relevant kontext i Supabase.
   * Matchar mot SQL-funktionen 'match_documents'.
   */ async performSearch(query, companyId) {
        try {
            // 1. Skapa embedding för användarens fråga
            const queryEmbedding = await this.embeddings.embedQuery(query);
            // 2. Anropa RPC-funktionen i Supabase
            // Vi sätter match_count till 5 för att få tillräckligt med kontext
            const { data: result, error } = await this.supabase.rpc('match_documents', {
                query_embedding: queryEmbedding,
                match_threshold: 0.5,
                match_count: 5,
                filter_company_id: companyId
            });
            if (error) {
                console.error("Error searching Supabase:", error);
                throw new Error(`Search failed: ${error.message}`);
            }
            return result;
        } catch (error) {
            console.error("Error in performSearch:", error);
            throw error;
        }
    }
}
}),
"[project]/src/prompts/systemPrompts.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NORA_SYSTEM_PROMPT",
    ()=>NORA_SYSTEM_PROMPT
]);
const NORA_SYSTEM_PROMPT = `
Du är NORA, en professionell, hjälpsam och säljorienterad AI-assistent som representerar företaget beskrivet i kontexten nedan.

Ditt mål är att besvara besökarens frågor korrekt baserat *enbart* på den tillhandahållna informationen (Context).

REGLER FÖR DINA SVAR:
1. Svara alltid med en vänlig och professionell ton, som en kunnig medarbetare på företaget.
2. Basera ditt svar 100% på "CONTEXT" nedan. Hitta inte på fakta.
3. Om svaret inte finns i kontexten, svara INTE "Jag vet inte". Säg istället något i stil med:
   "Jag har inte exakta detaljer om det just nu, men jag kan koppla dig till vårt säljteam för mer information," eller "Den specifika informationen finns inte i min nuvarande utbildning, men berätta gärna mer om vad ni letar efter så kan jag se vad jag hittar."
4. Håll svaren koncisa men informativa. Använd markdown för listor om det passar.
5. Om användaren frågar vem du är, svara att du är NORA, en AI-agent som hjälper besökare att hitta rätt information.

CONTEXT:
{context}
`;
}),
"[project]/src/app/api/chat/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$ragService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/ragService.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$chat_models$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/chat_models/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/core/dist/messages/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$human$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/core/dist/messages/human.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$system$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/core/dist/messages/system.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$prompts$2f$systemPrompts$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/prompts/systemPrompts.ts [app-route] (ecmascript)");
;
;
;
;
;
const ragService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$ragService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RagService"]();
const chatModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$chat_models$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChatOpenAI"]({
    modelName: "gpt-4o",
    temperature: 0.7,
    streaming: true
});
async function POST(req) {
    try {
        const body = await req.json();
        const { message, companyId } = body;
        if (!message || !companyId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Message and companyId are required"
            }, {
                status: 400
            });
        }
        // 1. Sök relevant kontext (RAG)
        const searchResults = await ragService.performSearch(message, companyId);
        const contextText = searchResults.map((r)=>r.content).join("\n\n---\n\n");
        const sources = searchResults.map((r)=>r.metadata?.sourceURL).filter(Boolean);
        console.log(`Found ${searchResults.length} context chunks for query: "${message}"`);
        // 2. Bygg prompten
        const systemPromptEncoded = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$prompts$2f$systemPrompts$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NORA_SYSTEM_PROMPT"].replace("{context}", contextText || "Ingen specifik information hittades.");
        const messages = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$system$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SystemMessage"](systemPromptEncoded),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$messages$2f$human$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HumanMessage"](message)
        ];
        // 3. Skapa en stream för svaret
        const stream = new ReadableStream({
            async start (controller) {
                const streamResponse = await chatModel.stream(messages);
                for await (const chunk of streamResponse){
                    if (chunk.content) {
                        controller.enqueue(new TextEncoder().encode(chunk.content));
                    }
                }
                controller.close();
            }
        });
        // 4. Returnera streamen
        // Vi skickar sources i en custom header så klienten kan läsa dem
        return new Response(stream, {
            headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                'X-Sources': JSON.stringify(sources)
            }
        });
    } catch (error) {
        console.error("Chat error:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: error.message || "Internal Server Error"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__04228241._.js.map