module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/http2 [external] (http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[project]/src/services/crawlerService.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CrawlerService",
    ()=>CrawlerService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mendable$2f$firecrawl$2d$js$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mendable/firecrawl-js/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].config();
class CrawlerService {
    app;
    constructor(){
        const apiKey = process.env.FIRECRAWL_API_KEY;
        if (!apiKey) {
            throw new Error("FIRECRAWL_API_KEY is not defined in environment variables.");
        }
        this.app = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mendable$2f$firecrawl$2d$js$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            apiKey
        });
    }
    /**
   * Crawls a URL and returns the content in Markdown format.
   * Can be configured to crawl subpages or just a single page.
   * 
   * @param url The URL to crawl
   * @param limit Max number of pages to crawl (default 10)
   */ async crawlWebsite(url, limit = 10) {
        try {
            console.log(`Starting crawl for: ${url} with limit: ${limit}`);
            const crawlResponse = await this.app.crawl(url, {
                limit: limit,
                scrapeOptions: {
                    formats: [
                        'markdown'
                    ]
                }
            });
            if (crawlResponse.status !== 'completed') {
                throw new Error(`Failed to crawl URL. Status: ${crawlResponse.status}`);
            }
            console.log(`Successfully crawled ${crawlResponse.data.length} pages.`);
            return crawlResponse.data;
        } catch (error) {
            console.error("Error in crawlWebsite:", error);
            throw error;
        }
    }
    /**
   * Scrapes a single URL to get markdown content specifically.
   * Useful for quick lookups or precise page reading.
   */ async scrapePage(url) {
        try {
            const scrapeResponse = await this.app.scrape(url, {
                formats: [
                    'markdown'
                ]
            });
            // I V2 kastar scrape ofta fel direkt eller returnerar ett objekt.
            // Kontrollera om markdown finns.
            if (!scrapeResponse.markdown) {
                throw new Error(`Failed to scrape URL or no markdown found.`);
            }
            return scrapeResponse.markdown || "";
        } catch (error) {
            console.error("Error in scrapePage:", error);
            throw error;
        }
    }
}
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[project]/src/services/ragService.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RagService",
    ()=>RagService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/openai/dist/embeddings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@langchain/textsplitters/dist/index.js [app-route] (ecmascript) <locals>"); // Uppdaterad import
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$text_splitter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@langchain/textsplitters/dist/text_splitter.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].config();
class RagService {
    supabase;
    embeddings;
    splitter;
    constructor(){
        const sbUrl = process.env.SUPABASE_URL;
        const sbKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // OBS: Använd Service Role Key för att skriva till DB på backend
        if (!sbUrl || !sbKey) {
            throw new Error("Supabase URL or Service Role Key missing in environment variables.");
        }
        this.supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(sbUrl, sbKey);
        // Initiera OpenAI Embeddings (text-embedding-3-small)
        this.embeddings = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAIEmbeddings"]({
            modelName: "text-embedding-3-small"
        });
        // Konfigurera text splitter
        this.splitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$langchain$2f$textsplitters$2f$dist$2f$text_splitter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RecursiveCharacterTextSplitter"]({
            chunkSize: 1000,
            chunkOverlap: 200,
            separators: [
                "\n## ",
                "\n# ",
                "\n\n",
                "\n",
                " ",
                ""
            ]
        });
    }
    /**
   * Bearbetar, splittar och lagrar crawlad data.
   * @param documents Lista med objekt från Firecrawl (måste innehålla markdown och metadata)
   * @param companyId Unikt ID för företaget/sessionen
   */ async processAndStoreDocuments(documents, companyId) {
        console.log(`Processing ${documents.length} documents for company: ${companyId}`);
        for (const doc of documents){
            if (!doc.markdown) continue;
            // 1. Splitta texten i chunks
            // Vi skickar med metadata så den följer med varje chunk
            const splitDocs = await this.splitter.createDocuments([
                doc.markdown
            ], [
                {
                    source: doc.metadata?.sourceURL || 'unknown',
                    ...doc.metadata
                }
            ]);
            console.log(`Split document into ${splitDocs.length} chunks.`);
            // 2. Skapa embeddings för alla chunks
            const texts = splitDocs.map((d)=>d.pageContent);
            const vectors = await this.embeddings.embedDocuments(texts);
            // 3. Förbered data för Supabase
            const rowsToInsert = splitDocs.map((splitDoc, index)=>({
                    content: splitDoc.pageContent,
                    metadata: splitDoc.metadata,
                    embedding: vectors[index],
                    company_id: companyId
                }));
            // 4. Spara i Supabase
            const { error } = await this.supabase.from('knowledge_base') // Updated table name
            .insert(rowsToInsert);
            if (error) {
                console.error("Error inserting into Supabase:", error);
                throw new Error(`Failed to store credentials: ${error.message}`);
            }
        }
        console.log("All documents processed and stored successfully.");
    }
    /**
   * Söker efter relevant kontext i Supabase.
   * Matchar mot SQL-funktionen 'match_documents'.
   */ async performSearch(query, companyId) {
        try {
            // 1. Skapa embedding för användarens fråga
            const queryEmbedding = await this.embeddings.embedQuery(query);
            // Bestäm tröskelvärde baserat på frågans innehåll
            const lowerQuery = query.toLowerCase();
            const isPriceQuery = lowerQuery.includes('pris') || lowerQuery.includes('kostar') || lowerQuery.includes('kosta') || lowerQuery.includes('price') || lowerQuery.includes('cost');
            // Sänk tröskeln rejält för prisfrågor eftersom dessa rader ofta är korta och har låg semantisk likhet
            // Även generella frågor kan ha lägre matchning, så vi sätter en snällare grundnivå (0.35 istället för 0.5)
            const threshold = isPriceQuery ? 0.3 : 0.4;
            // 2. Anropa RPC-funktionen i Supabase
            // Vi ökar match_count till 10 för att fånga upp fler detaljer
            const { data: result, error } = await this.supabase.rpc('match_documents', {
                query_embedding: queryEmbedding,
                match_threshold: threshold,
                match_count: 10,
                filter_company_id: companyId
            });
            if (error) {
                console.error("Error searching Supabase:", error);
                throw new Error(`Search failed: ${error.message}`);
            }
            return result;
        } catch (error) {
            console.error("Error in performSearch:", error);
            throw error;
        }
    }
}
}),
"[project]/src/app/api/ingest/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST,
    "runtime",
    ()=>runtime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$crawlerService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/crawlerService.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$ragService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/ragService.ts [app-route] (ecmascript)");
;
;
const runtime = 'nodejs'; // Use nodejs runtime for heavier tasks if needed, though edge works for streaming usually. Stick to default or force nodejs for langchain stuff.
async function POST(req) {
    const body = await req.json();
    const { url, companyId } = body;
    if (!url || !companyId) {
        return new Response(JSON.stringify({
            error: "URL and companyId are required"
        }), {
            status: 400
        });
    }
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
        async start (controller) {
            try {
                const crawlerService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$crawlerService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CrawlerService"]();
                const ragService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$ragService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RagService"]();
                // 1. Crawla
                console.log(`Starting crawl for ${url}`);
                const crawledData = await crawlerService.crawlWebsite(url, 5);
                // Skicka "scraped"-event
                const count = crawledData ? crawledData.length : 0;
                controller.enqueue(encoder.encode(JSON.stringify({
                    type: 'scraped',
                    count,
                    pages: crawledData
                }) + '\n'));
                // 2. Bearbeta och spara
                if (count > 0) {
                    await ragService.processAndStoreDocuments(crawledData, companyId);
                }
                // Skicka "complete"-event
                controller.enqueue(encoder.encode(JSON.stringify({
                    type: 'complete'
                }) + '\n'));
                controller.close();
            } catch (error) {
                console.error("Ingestion error:", error);
                controller.enqueue(encoder.encode(JSON.stringify({
                    type: 'error',
                    error: error.message
                }) + '\n'));
                controller.close();
            }
        }
    });
    return new Response(stream, {
        headers: {
            'Content-Type': 'application/json',
            'Transfer-Encoding': 'chunked'
        }
    });
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__0d3c695f._.js.map